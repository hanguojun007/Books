---
title: "Data transformation.qmd"
author: "大番薯本薯"
date: "2025-01-20"
date-modified: "2025-01-20"
fig-width: 4
fig-height: 4
fig-align: center
execute:
  warning: false
---

# Data transformation

本章主要学习如何使用 `dplyr` 包对数据进行转换。

## Introduction

`dplyr` 包是 `tidyverse` 包的核心包之一，它提供了一组用于数据转换的函数。`dplyr` 包中的函数根据其可操控的对象分为：rows，columns，groups/tables。

`dplyr` 包中的函数都有一个共同的特点：它们都接受一个数据框作为第一个参数，并返回一个数据框，其他参数是数据框的列名（没有使用引号包裹）。

`nycflights13` 包是一个包含纽约市航班数据的包，我们将使用它来学习 `dplyr` 包。

管道符`|>`是R4.1.0版本引入的新特性，等同于`%>%`。

加载 tidyverse 包和 nycflights13 包。

```{r}
library(nycflights13)
library(tidyverse)
```

## Rows

-   `filter()`：筛选行数据，但是**不会改变行的原有顺序**。
-   `arrange()`：改变行顺序，但不筛选数据。
-   `distinct()`：去除重复行。

### filter()

函数第二个参数接受一个逻辑表达式，返回值为 `TRUE` 的行会被保留。

```{r}
flights |>
  filter(dep_delay > 120)
```

### arrange()

函数第二个参数接受一个变量名，根据该变量对行进行排序。如果提供多个变量名，则依次排序。使用 `desc()` 对变量进行降序排序。

```{r}
flights |>
  arrange(year, month, day, desc(dep_time))
```

### distinct()

当不提供变量名时，根据所有列保留数据中的不同行。提供列名时会根据指定列保留不同行，同时删除其他列，使用`.keep_all = TRUE` 可以保留其他列。

`distinct()` 只会保留数据中最先出现的行。所以如果行顺序改变，结果可能也会改变。

```{r}
flights |>
  distinct()

flights |>
  distinct(origin, dest)

flights |>
  distinct(origin, dest, .keep_all = TRUE)
```

## Columns

-   `mutate()` 根据存在的列创建新列
-   `select()` 选择列
-   `rename()` 重命名列
-   `relocate()` 改变列的位置

### mutate()

有四个内置参数：

-   `.by`: 按组操作，等同于`group_by()` + `mutate()` + `ungroup()`，其与`group_by()`的区别见`?dplyr_by`。
-   `.before`, `.after`: 控制新列的位置。
-   `.keep`: 控制哪些列保留在输出中。
    -   `"all"`: 保留所有列，默认。
    -   `"used"`: 只保留用于创建新列的列。
    -   `"unused"`: 只保留未用于创建新列的列。
    -   `"none"`: 只保留新列。

```{r}
flights |>
  mutate(
    gain = dep_delay - arr_delay,
    hours = air_time / 60,
    gain_per_hour = gain / hours,
    .keep = "used"
  )
```

### select()

`select()` 用于选择列，其参数可以是列名、列索引、列范围、列类型、逻辑表达式等。`select()` 还可以用来重命名列，使用方法`new_name = old_name`。

搭配下面函数，使得 `select()` 更加灵活：

##### 操作符

-   `:`: 选择连续的列。
-   `|`: 选择满足任意一个条件的列。
-   `&`: 选择同时满足多个条件的列。
-   `!`: 排除某些列。
-   `c()`: 组合多个选择条件。

::: {.callout-note}
你可能见过`-`，这是历史版本，推荐使用最新的`!`。
:::

##### 选择特殊列

-   `everything()`: 匹配所有列。
-   `last_col()`: 匹配最后一列。
-   `group_cols()`：匹配用来分组的列。

##### 匹配某种pattern的列

-   `starts_with("abc")`: 匹配以 "abc" 开头的列名。
-   `ends_with("xyz")`: 匹配以 "xyz" 结尾的列名。
-   `contains("ijk")`: 匹配包含 "ijk" 的列名。
-   `matches("(.)\\1")`: 匹配正则表达式。
-   `num_range("x", 1:3)`: 匹配 x1, x2, x3。

这五类函数除匹配规则参数外，还有`ignore.case`和`vars`两个参数；可以单独使用，详细见`?tidyselect::starts_with`。

##### 选择来自字符串向量中的列

-   `all_of(x)`: 匹配 x 中的所有列，缺失某列会报错。
-   `any_of(x)`: 匹配 x 中的任意列，缺失某列不会报错。

##### 选择某种类型的列

-   `where(is.numeric)`: 匹配所有数值列。

当`select()`选择的列名有重复时，会忽略重复项。

### rename()

`rename()` 函数用于重命名列，语法为 `rename(新列名 = 旧列名)`。

### relocate()

`relocate()` 函数用于移动列的位置，语法为 `relocate(列名, .before = 列名, .after = 列名)`。

待移动的列名可以遵循 `select()` 的语法。

## Groups

### group_by()

`group_by()` 函数用于对数据进行分组，语法为 `group_by(列名)`。`group_by()` 会改变数据的分组结构，但不会改变数据本身。被分组的数据在打印时会显示`# Groups: 列名 [组数]`。

```{r}
flights |>
  group_by(month)
#> # A tibble: 336,776 × 19
#> # Groups:   month [12]
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
#>   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
#> 1  2013     1     1      517            515         2      830            819
#> 2  2013     1     1      533            529         4      850            830
#> 3  2013     1     1      542            540         2      923            850
#> 4  2013     1     1      544            545        -1     1004           1022
#> 5  2013     1     1      554            600        -6      812            837
#> 6  2013     1     1      554            558        -4      740            728
#> # ℹ 336,770 more rows
#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>, …
```











```{r}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")
select(flights, any_of(variables))
flights |> select(contains("TIME", ignore.case = FALSE))

flights |> rename(air_time_min = air_time) |>
  relocate(air_time_min, .before = 1)


relocate()
```
